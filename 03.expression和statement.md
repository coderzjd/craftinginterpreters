### 一、expression和statement

+ expression 一定有“值”，statement 一定有“副作用”；
+ statement 可以包含 expression，但 expression 不能反过来包含 statement（ES 序列表达式除外）。
+ expression后跟分号（;）可以将expression提升为statement状态

| 类别             | 是否存在结果值                      | 作用           | 举例                                       |
| -------------- | ---------------------------- | ------------ | ---------------------------------------- |
| **Expression** | ✅ 有值                         | 被求值后**返回数据** | `1 + 2` → `3`；`a?.b` → `undefined` 或 `b` |
| **Statement**  | ❌ 无值（返回 `Completion Record`） | **控制流程/副作用** | `if`；`for`；`throw`；`return`              |


| 代码                    | AST 节点类型                                 | 类别      | 说明          |
| --------------------- | ---------------------------------------- | ------- | ----------- |
| `foo`                 | `Identifier` → 属于 **Expression**         | 有值      | 变量读取即值      |
| `foo = 1`             | `AssignmentExpression`                   | **表达式** | 值是 `1`（右手）  |
| `foo();`              | `ExpressionStatement` > `CallExpression` | **语句**  | 语句壳里套一个表达式  |
| `if (x > 0) { ... }`  | `IfStatement`                            | **语句**  | 无值，只控制流程    |
| `() => { return 1; }` | `BlockStatement` 主体                      | **语句块** | 花括号体 = 语句列表 |
| `() => 1`             | `BinaryExpression` 主体                    | **表达式** | 无花括号 → 隐式返回 |

### 二、有的编程语言没有statement，全都转化为expression 
+ 这么做的好处
    - 语法统一 任何地方都能嵌入控制流，减少特殊-case。
    - 函数式风格 更容易组合、链式、惰性求值。
    - 作用域即值 let x = { let a = 1; a + 2 }; 直接返回 3，无需额外 return。
    - 编译器实现更简单 AST 只有一类节点——表达式；语句层消失，前端代码量直线下降。

| 语言          | 控制流写法                                | 返回值   | 备注                |
| ----------- | ------------------------------------ | ----- | ----------------- |
| **Scheme**  | `(if (> a 0) 1 0)`                   | 1 或 0 | 根本没有 statement 概念 |
| **OCaml**   | `let x = if a > 0 then 1 else 0`     | 同上    | 最后一个表达式即块值        |
| **Haskell** | `x = if a > 0 then 1 else 0`         | 同上    | 惰性 + 纯函数式         |
| **Rust**    | `let x = if a > 0 { 1 } else { 0 };` | 同上    | 唯一限制：两分支类型必须一致    |
| **Ruby**    | `x = if a > 0; 1; else; 0; end`      | 同上    | 语法层全表达式，nil 充当中性值 |
| **Elixir**  | `x = if a > 0, do: 1, else: 0`       | 同上    | 宏展开后仍是 AST 表达式    |


