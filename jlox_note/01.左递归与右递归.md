## 左递归与右递归案例对比

### 定义四则运算
1. 加减乘除小括号，数字
2. 优先级， 数字| () 大于 乘除 大于 加减
3. 从左往右计算
4. 获取token序列： `[NUMBER(1),PLUS(+),NUMBER(3),STAR(*),NUMBER(1),MINUS(-),NUMBER(2),EOF]`

### 左递归实现
1. 文法 
    ```bash
    expr  → term (( "+" | "-" ) term)*
    term  → factor (( "*" | "/" ) factor)*
    factor→ NUMBER | "(" expr ")"
    ```
2. 代码实现
    ```bash
    tokens = [...]        # 上面列表
    pos = 0

    def consume(typ):
        global pos
        if tokens[pos].type == typ:
            pos += 1
            return tokens[pos-1]
        raise Error()

    def factor():
        if tokens[pos].type == 'NUMBER':
            return ('num', int(consume('NUMBER').lexeme))
        if tokens[pos].type == 'LEFT_PAREN':
            consume('LEFT_PAREN')
            node = expr()
            consume('RIGHT_PAREN')
            return node
        raise Error()

    def term():
        node = factor()
        while tokens[pos].type in ('STAR', 'SLASH'):
            op = consume(tokens[pos].type)
            right = factor()
            node = ('bin', op.lexeme, node, right)
        return node

    def expr():
        node = term()
        while tokens[pos].type in ('PLUS', 'MINUS'):
            op = consume(tokens[pos].type)
            right = term()
            node = ('bin', op.lexeme, node, right)
        return node
    ```
3. AST
    ```bash 
    ('-',
    ('+',
        ('num',1),
        ('*', ('num',3), ('num',1))),
    ('num',2))
    ```
### 右递归实现
1. 文法
    ```bash
    expr  → term (("+"|"-") expr)?
    term  → factor (("*"|"/") term)?
    factor→ NUMBER | "(" expr ")"
    ```
2. 代码实现
    ```bash
    def factor():
        if tokens[pos].type == 'NUMBER':
            return ('num', int(consume('NUMBER').lexeme))
        if tokens[pos].type == 'LEFT_PAREN':
            consume('LEFT_PAREN')
            node = expr()
            consume('RIGHT_PAREN')
            return node
        raise Error()

    def term():
        node = factor()
        if tokens[pos].type in ('STAR', 'SLASH'):
            op = consume(tokens[pos].type)
            right = term()               # 直接递归
            return ('bin', op.lexeme, node, right)
        return node

    def expr():
        node = term()
        if tokens[pos].type in ('PLUS', 'MINUS'):
            op = consume(tokens[pos].type)
            right = expr()               # 直接递归
            return ('bin', op.lexeme, node, right)
        return node
    ```
3. AST
    ```bash
    ('+',
    ('*', ('num',1), ('num',3)),
    ('-', ('num',1), ('num',2)))
    ```
### 总结
+ 左递归从左往右结合
+ 右递归从右往左结合
+ 人类语言和数学大部分都是从左往右：`左结合`
+ 左递归≈90–97% 的产生式，右递归≈3–10% 且集中在“天生右结合”的那几个语法点比如：`a=b=c`
+ 这里用右递归不符合四则运算从左往右会出错
+ 一张 CFG 里混用左右递归，parser实现不一样
+ 在 CFG 这一层，左递归才是“人脑直觉”：
  
### 工程建议
+ parser实现栈深度差异
    - 左递归手工改循环后，栈深 O(1)，适合超长表达式（C 的 a+b+c+… 几千项也不会爆栈）。
    - 右递归每次真递归，栈深 O(n)；在浏览器里跑 JS parser 时，有人用 a=b=c=d=… 两千次就 RangeError。
+ 左递归文法不能直接喂给“纯递归下降”
  - YACC/Bison 会自动帮你消左递归；
手写递归下降时，必须把 * 改 while，否则一调用就无限递归
+ 左右递归混用
  - 混用时的“优先级边界”一定放在不同非终结符
别把左递归和右递归塞到同一层产生式，否则优先级会崩
+ 根据AST一眼看结合性的可视化技巧
  - 所有左递归节点往左下长
  - 所有右递归节点往**右下**长：  
+ 右递归文法、但在解析的同时把“能算的先算出来”
  - 5 - 3 - 1 右递归 AST 本会挂成
  - 左、右操作数都是数字吗？是就直接算，再把算好的数字当新节点返回
  - 代码演示
    ```bash
    def fold(node):
        """如果节点是纯数字，返回int；否则返回原节点"""
        if isinstance(node, tuple) and node[0] == 'num':
            return node[1]
        return node

    def expr():
        node = term()
        if tokens[pos].type in ('PLUS', 'MINUS'):
            op = consume(tokens[pos].type)
            right = expr()               # 右递归，先拿右边整个表达式
            # ===== 常量折叠 =====
            L = fold(node)
            R = fold(right)
            if isinstance(L, int) and isinstance(R, int):
                # 直接算出数字，返回新“数字节点”
                val = (L + R) if op.lexeme == '+' else (L - R)
                return ('num', val)
            # 不能折叠，按原样生成右结合节点
            return ('bin', op.lexeme, node, right)
        return node
    ```