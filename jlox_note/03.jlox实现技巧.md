# jlox 实现技巧速查表（完结版）
&gt; 一行代码一行注解，哪里是语法糖、哪里是语义坑、哪里是运行时黑科技，一眼分清。

---

## 1 类 & 对象（class/instance/inheritance）
| 技巧点 | 源码位置 | 实现摘要 | 备注/坑 |
| --- | --- | --- | --- |
| **this 绑定** | `visitThisExpr()` | 把 `this` 当成**普通词法变量**，在 `Environment` 里占坑名 `"this"`；进入方法前由解释器手动 `define("this", instance)` | 无需新 AST 节点，靠“预置变量”搞定 |
| **init 零 return** | `visitReturnStmt()` | 若函数是 `INITIALIZER` 且 `value == null` → **强制改返回值为 `this`** | 语法允许空 return，语义层**自动替换成实例** |
| **init 显式 return** | 同上 | 若 init 里写 `return 42;` → **直接抛 RuntimeError** | 保证构造函数**绝不返回非 this 值** |
| **class ≠ callable** | `visitCallExpr()` | 检查 `callee instanceof LoxClass` → 抛 `RuntimeError` | 先创建实例，再手动调 init，**class 本身不可直接 `()`** |
| **实例存储** | `LoxInstance.java` | 用 `Map&lt;String, Object&gt; fields` 存字段；`get/set` 只查本实例，**方法走 class** | 字段与方法**分离存储**，方法永远动态查找 |
| **继承链** | `LoxClass` 含 `final LoxClass superclass` | 查找方法时**先查本类，再递归 parent**；找不到才抛 `RuntimeError` | 单继承 + 运行时动态派发 |
| **super 解析** | `visitSuperExpr()` | 把 `super` 也当**预置变量**，距离 1 的封装：解释器在**子类方法调用前** `define("super", superclass)` | 离 this 只隔一层环境，**静态绑定父类** |

---

## 2 函数（作用域、闭包、空 return）
| 技巧点 | 源码位置 | 实现摘要 | 备注/坑 |
| --- | --- | --- | --- |
| **作用域链** | `Environment.enclosing` | 链表式**静态作用域**，查找时一路 `enclosing.get()` 直到全局 | 深度 = 源码嵌套深度，O(n) 但层数极少 |
| **块级进出** | `visitBlockStmt()` | **保存-恢复**模式：进入 block `Environment previous = current;` → 新建局部表 → 执行完 `current = previous;` | 弹出只需一次赋值，**无 malloc/free** |
| **闭包捕获** | `LoxFunction.closure` | 函数对象**持有定义时刻的 current 环境指针**；调用时以该指针为父作用域新建帧 | Java GC 自动延长变量生命周期，**正统闭包语义** |
| **空 return 禁止** | `visitReturnStmt()` | 非 init 函数若 `value == null` → **直接抛 RuntimeError** | 杜绝隐式 `undefined`，强制显式返回值 |
| **递归绑定** | `resolveFunction()` | **先 define 占位（null）→ 再创建函数对象 → 再 assign 覆盖** | 让函数体里**超前引用自己**不报错 |

---

## 3 语法脱糖 & 语义检查（静态期）
| 技巧点 | 源码位置 | 实现摘要 | 备注/坑 |
| --- | --- | --- | ---|
| **多字符运算符** | `Scanner` 超前看 | `!` 后跟 `=` → 合成 `!=` token；**无回溯单遍扫描** | 手写状态机，**无正则引擎** |
| **注释剔除** | 同一遍扫描 | `//` 行尾截断；`/* */` 用嵌套计数器**支持块注释嵌套** | 嵌套 `/* /* */ */` 能正确跳过 |
| **this/super 词法关键字** | 在 Scanner 里**硬编码字符串判断** | `if (text.equals("this")) return THIS;` | **无关键字表**，直接字符串匹配，简单暴力 |
| **变量重复声明** | `define()` 检查 | 当前环境**已存在同名** → 抛 `RuntimeError` | 只查当前块，**允许外层遮蔽** |
| **函数重载** | ❌ **无** | 同名函数后定义**直接覆盖**前定义 | 与 JS 一致，**靠作用域遮蔽模拟重载** |

---

## 4 运行时 & 性能小招
| 技巧点 | 源码位置 | 实现摘要 | 备注/坑 |
| --- | --- | --- | --- |
| **字节码？无** | 全程 AST walker | 解释器直接 `visit()` → **无编译阶段**，启动快，执行慢 | 教学向，clox 才引入字节码 |
| **短路运算符** | `visitLogicalExpr()` | **手动 if** 不 eval 右节点：  
`if (left) return left; else return evaluate(right);` | `and/or` **语义层保证短路**，非 AST 改造 |
| **error panic 模式** | `synchronize()` | 遇到 parse 错误 → **跳 token 直到下一个 `;` 或 `}`** | 让 parser **继续往下走**，一次报多个语法错 |
| **GC？无** | 靠 Java GC | 对象、环境、函数都由 JVM 托管，**无手动 free** | 教学专注前端，clox 才写标记清除 |

---

## 5 一句话速记
&gt; **“链表套作用域，指针抓闭包，空 return 一刀切，this/super 预置变量，继承递归查父类，注释嵌套计数器，错误同步到分号。”**  
把这张表贴在屏幕边，**加新特性前先对号打钩**，就不会漏掉任何“隐形施工”。