
### 所有语言都有运行时开销
| 语言       | 运行时形式      | 内存管理      | 谁实现的      | 透明度    |
| -------- | ---------- | --------- | --------- | ------ |
| **Java** | 显式JVM      | 自动GC      | Oracle/开源 | 完全可见   |
| **Rust** | 隐式运行时      | 所有权+drop  | 编译器生成     | 基本隐藏   |
| **C++**  | libstdc++等 | RAII+手动   | 编译器+标准库   | 部分可见   |
| **C**    | libc       | 手动+malloc | 操作系统提供    | 需要显式链接 |

### 跨平台解决方案
+ Java:    源代码 → 字节码 → JVM(跨平台) → 机器码
+ Rust:    源代码 → LLVM IR → 后端 → 各平台机器码 + 运行时库
+ C++:     源代码 → 各平台机器码 + 标准库
+ C:       源代码 → 各平台机器码 + libc
  
### 现代语言的"OS调用抽象谱系"
| 语言       | 抽象层次 | 内存管理调用链                       | 透明度   |
| -------- | ---- | ----------------------------- | ----- |
| **Lox**  | 超高   | Lox对象 → clox VM → malloc → OS | 完全隐藏  |
| **Java** | 高    | Java对象 → JVM → malloc → OS    | 基本隐藏  |
| **Rust** | 中    | Rust值 → alloc → malloc → OS   | 部分可见  |
| **C++**  | 低    | C++对象 → new → malloc → OS     | 大部分可见 |
| **C**    | 最低   | malloc → OS                   | 直接可见  |


### 洞察价值
  + "Java有GC，Rust/C++没有"这个说法本身就是错误的
  + 正确的说法是："Java有自动运行的GC，Rust/C++有程序员控制的GC"
    - Java："内存管理太重要，必须让专业VM来处理"
    - Rust："内存管理可以编译期解决，让程序员用所有权控制"
    - C++："内存管理是程序员的艺术，给你完全控制权"
    - C："内存管理就是操作系统调用，别搞复杂了"

### clox的精髓
+ 为Lox语言量身定制的优化运行时
+ 去除了JVM的通用性包袱
+ 避免了jvm"退化到Object再恢复"的性能损耗
+ 不是字节码本身快，而是clox避免了JVM那种"先退化再恢复"的冗余过程！

### rust使用LLVM路线
1. 源码 → AST（语法树）
   - rustc 先解析出普通 AST，保留泛型、trait 约束等高级语义。
2. AST → HIR（High-level IR）
   - 脱糖：把 for、if let 等语法糖改成 loop / match
   - 建立节点编号、作用域树，方便后续类型检查
   - HIR 仍保留泛型——这一步只是“更干净的 AST”
3. HIR → MIR（Mid-level IR）:重头戏来了
    - 类型检查完毕，泛型被单态化——为每个具体类型生成独立函数体
    - 控制流变成基本块 + SSA 形式，方便做数据流分析
    - 插入drop 语义、生命周期检查、借用检查等 Rust 特有逻辑
    - 结果是一份带类型的、线性的、无泛型的控制流图
4. MIR → LLVM IR（Low-level IR），rustc 的 codegen 阶段把 MIR 一条一条翻译成 LLVM IR
    - MIR 的 add → LLVM add i32
    - MIR 的 call → LLVM call void @foo(...)
    - 自动加上调用约定、ABI 对齐、name mangling
    - 内存分配统一用 alloca / load / store 表示
    - 此时已完全语言无关，LLVM 只看见纯 SSA 指令流
5. LLVM 中端 & 后端
    - 中端优化：常量折叠、死代码消除、循环展开、SROA、内联 …
    - 后端降维：指令选择、寄存器分配、调度、发射汇编 / 机器码
    - 链接器把 .o 文件 + runtime 合成最终可执行文件

### Rust先把“AST 放飞”的抽象用所有权+生命周期『勒紧』成可证明安全的 MIR，再把这条“被捆好的绳子”翻译成 LLVM IR
```bash
graph TD
A[Rust 源码] -->|解析| B[AST]
B -->|脱糖| C[HIR<br/>仍保留泛型]
C -->|类型检查+单态化| D[MIR<br/>无泛型+SSA]
D -->|指令发射| E[LLVM IR<br/>语言无关]
E -->|Pass 优化| F[优化后 IR]
F -->| codegen | G[汇编 / 机器码]
G -->|链接| H[可执行文件]- 
```