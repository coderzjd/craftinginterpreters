### 1、GC 的首要目的是“自动回收那些程序再也用不到的内存”，而不是“回收一部分”。
+ 手动管理（C/C++）靠你显式 free/delete；
+ clox 的标记-清除 GC 靠运行时定期扫描，把“从根集合出发永远走不到”的对象整块释放，让程序继续 malloc 而不必关心释放细节；
+ 它不保证“回收最多”或“最快”，只保证安全性——活的对象不会误杀，死的对象最终会被清理。
+ 所以 GC 解决的核心问题是：在不停分配新对象的同时，自动识别并回收已死亡的内存，防止泄漏且不让开发者手动管理。


### 2、为什么不执行闭包分析
  1. 那么比如这段代码x变量实际上在closure(); 执行完成之后就可以释放
  2. 为啥还需GC算法分析呢？我知道这种变量没有堆栈语义化，是不知在哪里释放吗？
  3. 为啥不从闭包的角度分析呢？那个闭包是否还被使用？可以分析出来吗？
    ```js
    fun outer() {
    var x = "outside";
    fun inner() {
        print x;
    }

    return inner;
    }
    var closure = outer();
    closure();
    ```
### 3、 闭包分析 代价 > 收益，所以工业 VM 都不做「闭包-逃逸」分析，而是保守地依赖图可达性 GC。原因有三： 
        - 闭包是一等公民
            在 clox/Lua/JS 里，函数返回值、赋值、放进数组/表、再传出模块……任何路径都能让闭包“逃逸”到编译期看不见的地方。
            静态分析必须跨函数、跨模块、跨异步回调去证明“它后面一定不会被调用”，几乎做不到完备。
        - 语言允许动态反射: 编译期无法确定 f 到底指向谁，逃逸分析只能保守地认为“会逃逸”。
            ```js
            var f = Math.random() > 0.5 ? closure : function(){};
            f();        // 运行时才知道调的是谁
            ```
        - 成本与收益
          + 图可达 GC 只需根集合 + 遍历指针，O(N) 且与语言特性无关；
          + 精确逃逸分析要全程序指针分析 + 调用图 + 副作用建模，NP-Hard；
          + 即使分析出来，节省的也只是“提前释放”，GC 迟早也会回收，对总内存占用无差别。
### 4、结论
       + 静态分析闭包是否还被使用在理论上可行，但在动态、一等函数、反射、热更新的语言里过于复杂且不可靠，所以 clox（以及 Lua、JS、Python）都选择保守的可达性 GC：
### 5、GC这个思想确实挺省事的
+ malloc 自由，free 免了
    - 在 clox 里，接下来你会把 allocateObject()、copyString() 写到到处都是，却永远不用写 freeObject()——collectGarbage() 一次性帮你打包清场。
+ 接口干净，指针不裸奔
    - 所有对象都挂到 Obj 基类链表上，GC 只需扫描这条链表，不需要记录谁 malloc 了几次、有没有配对的 free；指针永远是 Obj* 类型，不强制用智能指针模板，C 代码也写得像脚本一样爽。
+ 循环引用？不用管
    - 闭包里套表、表里再塞闭包，甚至自己引用自己——可达性算法天然无视循环，标记阶段走得到就活，走不到就死，不存在 C++ 那种 shared_ptr 循环引用导致泄漏的坑。
+ 调试友好，Valgrind 放假
    - 手动管理下，90% 的 segfault 来自“use-after-free”或“double-free”；有了 GC，这两种错误直接被消灭，Valgrind 从“必开”变成“可选”，调试时间砍半。