### clox的GC实现流程

+ 根集合 → 灰栈
  - markRoots() 把 VM 当前可直接触及的对象（线程栈、CallFrame 常量池、全局表、运行时表、根 Upvalue、灰栈自身等）全部标记为 灰色 并压入 vm.grayStack。
+ 灰色蔓延 → 黑色
  - traceReferences() 不断从灰栈弹出对象：
    + 将其成员（ObjClosure 的 upvalue 表、ObjInstance 的字段表、ObjFunction 的常量表、ObjUpvalue 的 closed 值等）标灰并入栈；
自身转 黑色。
    + 直到灰栈为空，标记阶段结束，活对象全黑，死对象仍白。
    + 字符串去白
      - tableRemoveWhite(&vm.strings) 遍历内部化字符串表，删除表中尚未被标黑的条目，保证“内部化但已死”的字符串既不会留在表内，也不会在清扫阶段被误当成新对象的复用目标。
+ 清扫
  - allocateObject() 都会把新对象插到 vm.objects 链表的最前面一路顺着 next 指针走，就能一个不落地看到所有曾经分配出去的 Obj
  - sweep() 线性扫描整个vm.objects 链表：
    + 白对象 → 释放内存、从链表摘除；
    + 黑对象 → 退回白色（颜色复位），留给下一轮 GC。
    + 同时累加 vm.bytesAllocated，得到回收后的存活量。
+ 调整阈值
    + 按“存活量 × GC_HEAP_GROW_FACTOR”设置下一次触发 GC 的 vm.nextGC，然后退出。