# clox 闭包实现全景流程总结

## 1. 语法解析

- 读到 `fun` 关键字时，进入新的 `Compiler` 实例（`enclosing` 指向外层编译器）。
- 每遇到一个函数声明，都会新建一套编译环境，形成嵌套结构。

## 2. 局部变量与上值决议

- 对内层函数中出现的每个标识符：
  1. 先用 `resolveLocal()` 查找本层局部变量。
  2. 找不到就递归 `resolveUpvalue()` 到外层，找到后用 `addUpvalue(c, outer_slot, is_local)` 把“外层第几槽”记到本层函数的 `upvalues[]` 表里，并返回本层 upvalue 序号。

## 3. 字节码生成

- 对本地变量访问，生成 `OP_GET_LOCAL` / `OP_SET_LOCAL`。
- 对 upvalue 访问，生成 `OP_GET_UPVALUE` / `OP_SET_UPVALUE <upvalue_idx>`。
- 内层函数编译结束时，`endCompiler()` 产生 `ObjFunction*`，用 `OP_CLOSURE <const_idx>` 把它塞进常量池。
- 随后紧跟 `upvalueCount × 2` 个字节，内容为 `(isLocal_byte, slot_or_outer_upvalue_idx)`，即运行时捕获说明书。

## 4. 运行时创建闭包（OP_CLOSURE）

- VM 取出 `ObjFunction`，新建 `ObjClosure`。
- 按说明书逐条 `captureUpvalue()`：
  - `isLocal=1`：抓当前外层帧 `frame->slots[index]`。
  - `isLocal=0`：抓外层闭包 `upvalues[index]`。
- 结果装进 `closure->upvalues[]`，同一个栈地址只会建一份 `ObjUpvalue`（靠 `openUpvalues` 链表去重）。

## 5. 变量生命周期管理

- 块结束 `}` 时，`OP_CLOSE_UPVALUE` 立即关闭刚死的 slot。
- 函数返回 `OP_RETURN` 时，`closeUpvalues(frame->slots)` 批量关闭整帧仍打开的 upvalue。
- 关闭操作：把值搬入 `upvalue->closed`，指针改到 `&closed`，脱离栈。

## 6. 后续访问

- 任何闭包执行 `OP_GET_UPVALUE n` 都直接 `*closure->upvalues[n]->location` 读写——数据已在堆，与栈无关。

## 7. GC 保护

- `ObjClosure` 和 `ObjUpvalue` 都被标记为根对象，自动追踪，防止闭包活着时变量被回收。

---

## 总结

- **编译期**：把“要抓谁”编码成 upvalue 表。
- **运行时**：按表捕获、搬堆、脱栈。
- **清理**：块级结束/函数返回两级清理，保证无悬空指针。
- **GC**：负责长期存活，防止内存泄漏或悬挂指针。

> clox 闭包实现流程清晰、严谨，确保了闭包变量的正确捕获与生命周期