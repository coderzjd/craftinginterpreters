### 1、GC 的首要目的是“自动回收那些程序再也用不到的内存”，而不是“回收一部分”。
+ 手动管理（C/C++）靠你显式 free/delete；
+ clox 的标记-清除 GC 靠运行时定期扫描，把“从根集合出发永远走不到”的对象整块释放，让程序继续 malloc 而不必关心释放细节；
+ 它不保证“回收最多”或“最快”，只保证安全性——活的对象不会误杀，死的对象最终会被清理。
+ 所以 GC 解决的核心问题是：在不停分配新对象的同时，自动识别并回收已死亡的内存，防止泄漏且不让开发者手动管理。


### 2、为什么不执行逃逸分析
  1. 那么比如这段代码x变量实际上在closure(); 执行完成之后就可以释放
  2. 为啥还需GC算法分析呢？我知道这种变量没有堆栈语义化，是不知在哪里释放吗？
  3. 为啥不从闭包的角度分析呢？那个闭包是否还被使用？可以分析出来吗？
  4. 那么我感觉clox中有一些变量其实不用全部搬到heap上，比如一部分上值本身就存在前一段stack，只有逃逸的需要搬上heap
    ```js
    fun outer() {
    var x = "outside";
    fun inner() {
        print x;
    }

    return inner;
    }
    var closure = outer();
    closure();
    ```
### 3、 逃逸分析 代价 > 收益，所以工业 VM 都不做「闭包-逃逸」分析，而是保守地依赖图可达性 GC。原因有三： 
        - 闭包是一等公民
            在 clox/Lua/JS 里，函数返回值、赋值、放进数组/表、再传出模块……任何路径都能让闭包“逃逸”到编译期看不见的地方。
            静态分析必须跨函数、跨模块、跨异步回调去证明“它后面一定不会被调用”，几乎做不到完备。
        - 语言允许动态反射: 编译期无法确定 f 到底指向谁，逃逸分析只能保守地认为“会逃逸”。
            ```js
            var f = Math.random() > 0.5 ? closure : function(){};
            f();        // 运行时才知道调的是谁
            ```
        - 成本与收益
          + 图可达 GC 只需根集合 + 遍历指针，O(N) 且与语言特性无关；
          + 精确逃逸分析要全程序指针分析 + 调用图 + 副作用建模，NP-Hard；
          + 即使分析出来，节省的也只是“提前释放”，GC 迟早也会回收，对总内存占用无差别。
### 4、结论
       + 静态分析闭包是否还被使用在理论上可行，但在动态、一等函数、反射、热更新的语言里过于复杂且不可靠，所以 clox（以及 Lua、JS、Python）都选择保守的可达性 GC：
### 5、GC这个思想确实挺省事的
+ malloc 自由，free 免了
    - 在 clox 里，接下来你会把 allocateObject()、copyString() 写到到处都是，却永远不用写 freeObject()——collectGarbage() 一次性帮你打包清场。
+ 接口干净，指针不裸奔
    - 所有对象都挂到 Obj 基类链表上，GC 只需扫描这条链表，不需要记录谁 malloc 了几次、有没有配对的 free；指针永远是 Obj* 类型，不强制用智能指针模板，C 代码也写得像脚本一样爽。
+ 循环引用？不用管
    - 闭包里套表、表里再塞闭包，甚至自己引用自己——可达性算法天然无视循环，标记阶段走得到就活，走不到就死，不存在 C++ 那种 shared_ptr 循环引用导致泄漏的坑。
+ 调试友好，Valgrind 放假
    - 手动管理下，90% 的 segfault 来自“use-after-free”或“double-free”；有了 GC，这两种错误直接被消灭，Valgrind 从“必开”变成“可选”，调试时间砍半。

### 6、多语言内存分析
  + C/C++ 的“官方态度”就是：
      - 编译器默认不做逃逸分析，也没有 GC；
      - 对象到底放栈、放堆、还是放全局，完全由程序员写的代码决定；
      - 生命周期对不对，你自己看着办
  + Python 和 JS 的策略可以用同一句话概括：
    - “编译器/解释器不做任何‘闭包-逃逸’优化，所有局部变量只要被闭包捕获，一律堆分配；
    - 内存安全靠全自动可达性 GC 兜底，开发者完全不用关心指针是否悬空。
  + Java(半动态半静态)、Golang策略
    - 把“编译期能看得到的”尽量静态优化，把“运行时才能确定的”留给 JIT + 保守的可达性 GC；
    - 闭包/对象是否逃逸，就夹在中间——编译器先做一次‘轻量级逃逸’，JIT 再做一次‘重量级逃逸’，最后 GC 只认可达性。
    - Go 的逃逸分析补一句“失败只会回退到堆，正确性不变”，跟 Java 保持一致
  + Rust 的所有权+借用模型不需要逃逸分析了
    - 要么留在本栈帧，帧弹栈时自动 drop
    - 要么通过 move 整份转移到别的变量/闭包/堆/线程，原作用域立刻失效——中间态不存在，也就无需逃逸分析来猜它到底去哪儿。
    - 因为无 GC，所以编译期必须 100 % 确定，否则直接panic!